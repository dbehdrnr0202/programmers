# Segment Tree
segment tree(Segment Tree)는 배열 간격에 대한 정보를 이진 트리에 저장하는 자료구조입니다.
다음 예를 보겠습니다.
`A = [1, 2, 3, 4, 5 … ,N]` 라는 배열에 아래 연산을 M번 수행한다고 생각해봅시다.
배열의 범위 합을 구하는 Query 연산
`A[0] + A[1] + A[2] + … + A[N-1]`
i번째 배열 값을 v로 변경하는 Update 연산
`A[i] = v`
단순한 방법으로는 각각 배열에 접근하여 연산을 한다면 시간 복잡도는 1번 연산 O(N), 2번 연산 O(1)이 됩니다.
이 두 연산을 M번 수행한다면 총 시간 복잡도는 O(MN)+O(M) = O(MN)이 됩니다.
segment tree를 사용하면 범위 최소/최대 및 합계 Query 및 범위 Update를 O(logN) 시간에 해결할 수 있습니다.
위 두 연산에 segment tree를 사용한다면 O(MlogN) + O(MlogN) = O(MlogN) 시간으로 개선시킬 수 있습니다.

## Segment Tree 구조
segment tree는 이진트리이므로 간단한 선형 배열을 사용하여 나타낼 수 있습니다.
부모 노드의 인덱스가 i라면 2i은 왼쪽 자식 노드이고 2i+1은 오른쪽 자식 노드입니다.
segment tree의 각 노드에는 구간 정보가 저장되어 있습니다.
ex) 구간 합, 구간 최대/최소 값
다음은 배열 A = {1,2,3,4,5} 에 대한 segment tree를 시각화한 그림입니다.
각 노드에는 배열의 구간 합이 저장되어 있습니다.
리프 노드에는 주어진 배열(A) 값들이 저장되고 내부 노드에는 자식 노드의 합이 저장됩니다.


## segment tree 구현
segment tree에는 세 가지(Build, Query, Update) 작업이 있습니다.
여기서는 구간 합 정보를 저장하는 segment tree를 구현하는 방법을 알아보겠습니다.
segment tree는 전 이진트리(Full Binary Tree)입니다.
그렇기 때문에 크기가 n인 배열을 가지고 리프 노드가 n개인 segment tree를 만들 때 필요한 노드 수는 다음과 같습니다.
높이가 $$h=\lceil log_2n \rceil$$라면 필요한 배열 크기는 $$2^{h+1}-1$$이며 편의를 위해 $$2^{h+1}$$ 또는 $$4n$$으로 크기를 정하기도 합니다.


## Build
segment tree를 만드는 작업을 합니다.
구현은 다음과 같습니다.
segment tree는 재귀를 사용하여 구축할 수 있습니다.
트리를 순회하며 작업을 진행합니다.
리프 노드라면 배열(A)의 요소를 저장합니다.
내부 노드라면 구간 정보를 저장합니다. (예를 들어 구간 정보가 구간 합이라면 두 자식 노드의 합을 저장합니다.)
구현
여기서 start, end는 배열 A에 대한 범위입니다.

## Query
세그먼트 트리에서 구간 정보를 가져옵니다.
구현은 다음과 같습니다.
- 트리를 순회합니다.
- 노드가 나타내는 범위가 지정된 범위 밖에 있다면 0을 반환합니다.
- 노드가 나타내는 범위가 지정된 범위 내에 있다면 값을 반환합니다.
- 노드가 나타내는 범위가 지정된 범위 일부만 포함한다면 왼쪽 자식과 오른쪽 자식의 합을 반환합니다.
예를 들어 배열 A = {1,2,3,4,5}에서 2부터 4까지 구간 합을 구한다면 ( 3 + 9 = 12 )


## Update
- 트리를 순회합니다.
- index가 포함된 구간을 가지고 있는 자식 노드로 재귀합니다.
- 리프 노드라면 배열 값을 변경합니다.
- 내부 노드라면 구간 정보를 저장합니다. 
    - (예를 들어 구간 정보가 구간 합이라면 두 자식 노드의 합을 저장합니다.)